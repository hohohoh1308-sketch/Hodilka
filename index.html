<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D FPS Game - Telegram</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden;
            background: #17212b;
            touch-action: none;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #controls {
            position: absolute;
            bottom: 30px;
            right: 30px;
            z-index: 100;
        }
        .control-button {
            width: 70px;
            height: 70px;
            margin: 8px;
            border: none;
            border-radius: 50%;
            background: rgba(40, 40, 40, 0.7);
            backdrop-filter: blur(15px);
            color: white;
            font-size: 24px;
            font-weight: bold;
            opacity: 0.9;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }
        .control-button:active {
            opacity: 1;
            background: rgba(60, 60, 60, 0.9);
            transform: scale(0.95);
        }
        .control-row {
            display: flex;
            justify-content: center;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 14px;
            backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="hud">
            <div>Позиция: <span id="position">0, 0, 0</span></div>
            <div>Объектов: <span id="objectCount">0</span></div>
            <div>Используй свайпы для обзора</div>
        </div>
        <div id="controls">
            <div class="control-row">
                <button class="control-button" id="forward">↑</button>
            </div>
            <div class="control-row">
                <button class="control-button" id="left">←</button>
                <button class="control-button" id="backward">↓</button>
                <button class="control-button" id="right">→</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
        class FPSGame {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                
                this.moveState = {
                    forward: false,
                    backward: false,
                    left: false,
                    right: false
                };
                
                this.player = {
                    height: 1.7,
                    velocity: new THREE.Vector3(),
                    direction: new THREE.Vector3(),
                    moveSpeed: 0.15,
                    rotation: {
                        yaw: 0,    // Горизонтальный поворот
                        pitch: 0   // Вертикальный поворот
                    }
                };
                
                this.touch = {
                    isDragging: false,
                    lastX: 0,
                    lastY: 0,
                    sensitivity: 0.005
                };
                
                this.objects = [];
                this.groundSize = 100;
                
                this.init();
            }

            init() {
                this.initTelegram();
                this.setupScene();
                this.createSkybox();
                this.createGround();
                this.createEnvironment();
                this.setupLighting();
                this.setupControls();
                this.animate();
                this.setupResizeHandler();
            }

            initTelegram() {
                Telegram.WebApp.ready();
                Telegram.WebApp.expand();
                
                console.log('Telegram Mini App initialized');
                
                // Адаптируемся под тему Telegram
                const bgColor = Telegram.WebApp.themeParams.bg_color || '#17212b';
                document.body.style.background = bgColor;
            }

            setupScene() {
                this.scene = new THREE.Scene();
                
                // Камера от первого лица
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.set(0, this.player.height, 5);
                
                // Рендерер
                const canvas = document.getElementById('gameCanvas');
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas,
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            }

            createSkybox() {
                // Создаем небо с градиентом
                const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
                
                // Вершинный шейдер для градиентного неба
                const vertexShader = `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `;
                
                // Фрагментный шейдер для градиента от синего к голубому
                const fragmentShader = `
                    varying vec3 vWorldPosition;
                    void main() {
                        float height = normalize(vWorldPosition).y;
                        vec3 skyColor = mix(
                            vec3(0.4, 0.7, 1.0),    // Голубой внизу
                            vec3(0.1, 0.3, 0.8),    // Синий вверху
                            height * 0.5 + 0.5
                        );
                        gl_FragColor = vec4(skyColor, 1.0);
                    }
                `;
                
                const skyMaterial = new THREE.ShaderMaterial({
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    side: THREE.BackSide
                });
                
                const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                this.scene.add(sky);
            }

            createGround() {
                // Текстура травы
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const context = canvas.getContext('2d');
                
                // Рисуем текстуру травы
                context.fillStyle = '#2d5a27';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // Добавляем детали травы
                context.fillStyle = '#3a6b32';
                for (let i = 0; i < 2000; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const size = Math.random() * 3 + 1;
                    context.fillRect(x, y, size, size);
                }
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(20, 20);
                
                const groundGeometry = new THREE.PlaneGeometry(this.groundSize, this.groundSize);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    map: texture,
                    roughness: 0.8,
                    metalness: 0.2
                });
                
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
            }

            createEnvironment() {
                const objectsCount = 15;
                
                for (let i = 0; i < objectsCount; i++) {
                    this.createRandomObject();
                }
                
                // Добавляем несколько специальных объектов для ориентира
                this.createHouse(15, 0, 15);
                this.createTree(-10, 0, 8);
                this.createPyramid(5, 0, -12);
                this.createWall(-20, 0, -5);
                
                document.getElementById('objectCount').textContent = this.objects.length;
            }

            createRandomObject() {
                const types = ['box', 'sphere', 'cylinder'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                let geometry, material, mesh;
                const color = new THREE.Color(
                    Math.random() * 0.5 + 0.5,
                    Math.random() * 0.5 + 0.5,
                    Math.random() * 0.5 + 0.5
                );
                
                switch(type) {
                    case 'box':
                        geometry = new THREE.BoxGeometry(
                            Math.random() * 3 + 1,
                            Math.random() * 4 + 1,
                            Math.random() * 3 + 1
                        );
                        break;
                    case 'sphere':
                        geometry = new THREE.SphereGeometry(Math.random() * 2 + 0.5, 8, 6);
                        break;
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(
                            Math.random() * 1.5 + 0.5,
                            Math.random() * 1.5 + 0.5,
                            Math.random() * 3 + 1,
                            8
                        );
                        break;
                }
                
                material = new THREE.MeshStandardMaterial({ 
                    color: color,
                    roughness: 0.7,
                    metalness: 0.3
                });
                
                mesh = new THREE.Mesh(geometry, material);
                
                // Случайная позиция на поле
                const x = (Math.random() - 0.5) * (this.groundSize - 20);
                const z = (Math.random() - 0.5) * (this.groundSize - 20);
                
                mesh.position.set(x, geometry.parameters.height / 2, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                // Случайный поворот
                mesh.rotation.y = Math.random() * Math.PI * 2;
                
                this.scene.add(mesh);
                this.objects.push(mesh);
            }

            createHouse(x, y, z) {
                const group = new THREE.Group();
                
                // Основание дома
                const baseGeometry = new THREE.BoxGeometry(6, 4, 6);
                const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 2;
                base.castShadow = true;
                base.receiveShadow = true;
                group.add(base);
                
                // Крыша
                const roofGeometry = new THREE.ConeGeometry(4.5, 3, 4);
                const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.y = 5.5;
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                group.add(roof);
                
                // Дверь
                const doorGeometry = new THREE.BoxGeometry(1.5, 2.5, 0.2);
                const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
                const door = new THREE.Mesh(doorGeometry, doorMaterial);
                door.position.set(0, 1.25, 3.1);
                group.add(door);
                
                group.position.set(x, y, z);
                this.scene.add(group);
                this.objects.push(group);
            }

            createTree(x, y, z) {
                const group = new THREE.Group();
                
                // Ствол
                const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 3, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 1.5;
                trunk.castShadow = true;
                group.add(trunk);
                
                // Крона
                const crownGeometry = new THREE.SphereGeometry(2, 8, 6);
                const crownMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                const crown = new THREE.Mesh(crownGeometry, crownMaterial);
                crown.position.y = 4;
                crown.castShadow = true;
                group.add(crown);
                
                group.position.set(x, y, z);
                this.scene.add(group);
                this.objects.push(group);
            }

            createPyramid(x, y, z) {
                const geometry = new THREE.ConeGeometry(3, 4, 4);
                const material = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
                const pyramid = new THREE.Mesh(geometry, material);
                pyramid.position.set(x, 2, z);
                pyramid.rotation.y = Math.PI / 4;
                pyramid.castShadow = true;
                pyramid.receiveShadow = true;
                this.scene.add(pyramid);
                this.objects.push(pyramid);
            }

            createWall(x, y, z) {
                const geometry = new THREE.BoxGeometry(10, 3, 1);
                const material = new THREE.MeshStandardMaterial({ color: 0x808080 });
                const wall = new THREE.Mesh(geometry, material);
                wall.position.set(x, 1.5, z);
                wall.castShadow = true;
                wall.receiveShadow = true;
                this.scene.add(wall);
                this.objects.push(wall);
            }

            setupLighting() {
                // Основное освещение
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                // Направленный свет (солнце)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(50, 50, 25);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                this.scene.add(directionalLight);
            }

            setupControls() {
                this.setupMovementControls();
                this.setupTouchControls();
                this.setupCameraControls();
            }

            setupMovementControls() {
                // Клавиатура для тестирования
                document.addEventListener('keydown', (event) => {
                    switch(event.key.toLowerCase()) {
                        case 'w': case 'arrowup': this.moveState.forward = true; break;
                        case 's': case 'arrowdown': this.moveState.backward = true; break;
                        case 'a': case 'arrowleft': this.moveState.left = true; break;
                        case 'd': case 'arrowright': this.moveState.right = true; break;
                    }
                });
                
                document.addEventListener('keyup', (event) => {
                    switch(event.key.toLowerCase()) {
                        case 'w': case 'arrowup': this.moveState.forward = false; break;
                        case 's': case 'arrowdown': this.moveState.backward = false; break;
                        case 'a': case 'arrowleft': this.moveState.left = false; break;
                        case 'd': case 'arrowright': this.moveState.right = false; break;
                    }
                });
            }

            setupTouchControls() {
                const forward = document.getElementById('forward');
                const backward = document.getElementById('backward');
                const left = document.getElementById('left');
                const right = document.getElementById('right');
                
                const addButtonListeners = (button, direction) => {
                    const handleStart = () => this.moveState[direction] = true;
                    const handleEnd = () => this.moveState[direction] = false;
                    
                    button.addEventListener('touchstart', handleStart);
                    button.addEventListener('touchend', handleEnd);
                    button.addEventListener('touchcancel', handleEnd);
                    button.addEventListener('mousedown', handleStart);
                    button.addEventListener('mouseup', handleEnd);
                    button.addEventListener('mouseleave', handleEnd);
                };
                
                addButtonListeners(forward, 'forward');
                addButtonListeners(backward, 'backward');
                addButtonListeners(left, 'left');
                addButtonListeners(right, 'right');
            }

            setupCameraControls() {
                const canvas = this.renderer.domElement;
                
                // Обработка касаний для поворота камеры
                canvas.addEventListener('touchstart', (event) => {
                    if (event.touches.length === 1) {
                        this.touch.isDragging = true;
                        this.touch.lastX = event.touches[0].clientX;
                        this.touch.lastY = event.touches[0].clientY;
                        event.preventDefault();
                    }
                });
                
                canvas.addEventListener('touchmove', (event) => {
                    if (this.touch.isDragging && event.touches.length === 1) {
                        const deltaX = event.touches[0].clientX - this.touch.lastX;
                        const deltaY = event.touches[0].clientY - this.touch.lastY;
                        
                        // Поворот камеры
                        this.player.rotation.yaw -= deltaX * this.touch.sensitivity;
                        this.player.rotation.pitch -= deltaY * this.touch.sensitivity;
                        
                        // Ограничение вертикального поворота
                        this.player.rotation.pitch = Math.max(
                            -Math.PI / 2, 
                            Math.min(Math.PI / 2, this.player.rotation.pitch)
                        );
                        
                        this.touch.lastX = event.touches[0].clientX;
                        this.touch.lastY = event.touches[0].clientY;
                        event.preventDefault();
                    }
                });
                
                canvas.addEventListener('touchend', (event) => {
                    this.touch.isDragging = false;
                });
                
                // Мышь для тестирования на ПК
                canvas.addEventListener('mousedown', (event) => {
                    this.touch.isDragging = true;
                    this.touch.lastX = event.clientX;
                    this.touch.lastY = event.clientY;
                });
                
                canvas.addEventListener('mousemove', (event) => {
                    if (this.touch.isDragging) {
                        const deltaX = event.clientX - this.touch.lastX;
                        const deltaY = event.clientY - this.touch.lastY;
                        
                        this.player.rotation.yaw -= deltaX * this.touch.sensitivity;
                        this.player.rotation.pitch -= deltaY * this.touch.sensitivity;
                        
                        this.player.rotation.pitch = Math.max(
                            -Math.PI / 2, 
                            Math.min(Math.PI / 2, this.player.rotation.pitch)
                        );
                        
                        this.touch.lastX = event.clientX;
                        this.touch.lastY = event.clientY;
                    }
                });
                
                canvas.addEventListener('mouseup', () => {
                    this.touch.isDragging = false;
                });
                
                canvas.addEventListener('mouseleave', () => {
                    this.touch.isDragging = false;
                });
            }

            updateMovement() {
                // Сбрасываем скорость
                this.player.velocity.set(0, 0, 0);
                
                // Применяем поворот камеры
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.player.rotation.yaw;
                this.camera.rotation.x = this.player.rotation.pitch;
                
                // Получаем направление камеры (без вертикальной составляющей)
                this.camera.getWorldDirection(this.player.direction);
                this.player.direction.y = 0;
                this.player.direction.normalize();
                
                // Вектор для движения вбок
                const right = new THREE.Vector3();
                right.crossVectors(this.player.direction, this.camera.up);
                
                // Применяем движение
                if (this.moveState.forward) {
                    this.player.velocity.add(this.player.direction);
                }
                if (this.moveState.backward) {
                    this.player.velocity.sub(this.player.direction);
                }
                if (this.moveState.left) {
                    this.player.velocity.sub(right);
                }
                if (this.moveState.right) {
                    this.player.velocity.add(right);
                }
                
                // Нормализуем и применяем скорость
                if (this.player.velocity.lengthSq() > 0) {
                    this.player.velocity.normalize();
                    this.player.velocity.multiplyScalar(this.player.moveSpeed);
                }
                
                // Обновляем позицию камеры
                this.camera.position.add(this.player.velocity);
                
                // Ограничиваем игрока в пределах поля
                const halfGround = this.groundSize / 2 - 5;
                this.camera.position.x = THREE.MathUtils.clamp(this.camera.position.x, -halfGround, halfGround);
                this.camera.position.z = THREE.MathUtils.clamp(this.camera.position.z, -halfGround, halfGround);
                
                // Фиксируем высоту (игрок не летает)
                this.camera.position.y = this.player.height;
                
                // Обновляем HUD
                this.updateHUD();
            }

            updateHUD() {
                const pos = this.camera.position;
                document.getElementById('position').textContent = 
                    `${Math.round(pos.x)}, ${Math.round(pos.y)}, ${Math.round(pos.z)}`;
            }

            setupResizeHandler() {
                Telegram.WebApp.onEvent('viewportChanged', this.handleResize.bind(this));
                window.addEventListener('resize', this.handleResize.bind(this));
            }

            handleResize() {
                const width = window.innerWidth;
                const height = Telegram.WebApp.viewportHeight || window.innerHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                this.updateMovement();
                this.renderer.render(this.scene, this.camera);
            }

            dispose() {
                this.scene.traverse((object) => {
                    if (object.isMesh) {
                        if (object.geometry) object.geometry.dispose();
                        if (object.material) {
                            if (Array.isArray(object.material)) {
                                object.material.forEach(material => material.dispose());
                            } else {
                                object.material.dispose();
                            }
                        }
                    }
                });
                
                if (this.renderer) {
                    this.renderer.dispose();
                }
            }
        }

        // Инициализация игры
        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new FPSGame();
        });

        window.addEventListener('beforeunload', () => {
            if (game) {
                game.dispose();
            }
        });
    </script>
</body>
</html>